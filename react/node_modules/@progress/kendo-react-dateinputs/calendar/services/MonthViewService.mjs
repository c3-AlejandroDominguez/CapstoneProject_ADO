/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { addDays as g, addWeeks as N, addMonths as h, firstDayOfMonth as y, lastDayOfMonth as D, dayOfWeek as W, getDate as u, durationInMonths as d } from "@progress/kendo-date-math";
import { Action as o } from "../models/NavigationAction.mjs";
import { EMPTY_SELECTIONRANGE as Y } from "../models/SelectionRange.mjs";
import { range as w, getToday as U, isInRange as T, isInSelectionRange as _ } from "../../utils.mjs";
const $ = [[]], S = 7, C = 6, G = 6, P = 0, z = {
  [o.Left]: (i) => g(i, -1),
  [o.Up]: (i) => N(i, -1),
  [o.Right]: (i) => g(i, 1),
  [o.Down]: (i) => N(i, 1),
  [o.PrevView]: (i) => h(i, -1),
  [o.NextView]: (i) => h(i, 1),
  [o.FirstInView]: (i) => y(i),
  [o.LastInView]: (i) => D(i)
};
class X {
  constructor(t) {
    this.intl = t;
  }
  addToDate(t, e) {
    return h(t, e);
  }
  datesList(t, e) {
    return w(0, e).map((n) => h(t, n));
  }
  data(t) {
    const {
      cellUID: e,
      focusedDate: n,
      isActiveView: l,
      max: r,
      min: a,
      selectedDate: c,
      selectionRange: m = Y,
      viewDate: f
    } = t;
    if (!f)
      return $;
    const M = y(f), R = D(f), b = W(M, this.intl.firstDay(), -1), q = w(0, S), V = U();
    return w(0, C).map((v) => {
      const L = g(b, v * S);
      return q.map((k) => {
        const s = this.normalize(g(L, k), a, r), p = s < M || s > R, A = this.isEqual(s, m.start), I = this.isEqual(s, m.end), E = !A && !I && _(s, m), F = l && (Array.isArray(c) ? this.isSelectedFromArray(s, c, a, r) : T(c, a, r) && this.isEqual(s, c)), O = this.isEqual(s, n) && !p;
        return {
          formattedValue: this.value(s),
          id: `${e}${s.getTime()}`,
          isFocused: O,
          isSelected: F,
          isInRange: T(s, a, r),
          isWeekend: this.isWeekend(s),
          isRangeStart: A,
          isRangeMid: E,
          isRangeEnd: I,
          isRangeSplitStart: E && this.isEqual(s, M),
          isRangeSplitEnd: E && this.isEqual(s, R),
          isToday: this.isEqual(s, V),
          title: this.cellTitle(s),
          value: s,
          isOtherMonth: p
        };
      });
    });
  }
  isEqual(t, e) {
    return !t || !e ? !1 : u(t).getTime() === u(e).getTime();
  }
  isSelectedFromArray(t, e, n, l) {
    let r = !1;
    return e.forEach((a) => {
      T(t, n, l) && this.isEqual(t, a) && (r = !0);
    }), r;
  }
  isInArray(t, e) {
    return !!e.length && y(e[0]) <= t && t <= D(e[e.length - 1]);
  }
  isInRange(t, e, n) {
    const l = u(t), r = !e || u(e) <= l, a = !n || l <= u(n);
    return r && a;
  }
  isInSameView(t, e) {
    return d(t, e) === 0;
  }
  isRangeStart(t) {
    return !t.getMonth();
  }
  move(t, e) {
    const n = z[e];
    return n ? n(t) : t;
  }
  cellTitle(t) {
    return this.intl.formatDate(t, "D");
  }
  navigationTitle(t) {
    return t ? this.isRangeStart(t) ? t.getFullYear().toString() : this.abbrMonthNames()[t.getMonth()] : "";
  }
  title(t) {
    return `${this.wideMonthNames()[t.getMonth()]} ${t.getFullYear()}`;
  }
  rowLength(t) {
    return S + (t ? 1 : 0);
  }
  skip(t, e) {
    return d(e, t);
  }
  total(t, e) {
    return d(t, e) + 1;
  }
  value(t) {
    return t ? t.getDate().toString() : "";
  }
  viewDate(t, e, n = 1) {
    return d(t, e) < n ? h(t, -1) : t;
  }
  isWeekend(t) {
    const e = t.getDay();
    return e === G || e === P;
  }
  abbrMonthNames() {
    return this.intl.dateFormatNames({ nameType: "abbreviated", type: "months" });
  }
  normalize(t, e, n) {
    return t < e && this.isEqual(t, e) ? u(e) : t > n && this.isEqual(t, n) ? u(n) : t;
  }
  wideMonthNames() {
    return this.intl.dateFormatNames({ nameType: "wide", type: "months", standAlone: !0 });
  }
}
export {
  X as MonthViewService
};
